#!/usr/bin/env bash
set -e
# Category: Utility
# Description: Backs up Odoo data manually (PostgreSQL dump + filestore).
# Usage: ./scripts/backupdata_manual.sh
# Dependencies: zip, pg_dump, sudo, git

# Detect Repository Owner to run non-root commands as that user
CURRENT_DIR=$(dirname "$(readlink -f "$0")")
CURRENT_DIR_USER=$(stat -c '%U' "$CURRENT_DIR")
PATH_TO_ODOO=$(sudo -u "$CURRENT_DIR_USER" git -C "$(dirname "$(readlink -f "$0")")" rev-parse --show-toplevel)
SERVICE_NAME=$(basename "$PATH_TO_ODOO")
REPOSITORY_OWNER=$(stat -c '%U' "$PATH_TO_ODOO")

# Configuration
ENV_FILE=".env"
UPDATE_SCRIPT="./scripts/update-env-file.sh"
MAX_BACKUPS=3

# --- Logging Functions & Colors ---
# Define colors for log messages
readonly COLOR_RESET="\033[0m"
readonly COLOR_INFO="\033[0;34m"
readonly COLOR_SUCCESS="\033[0;32m"
readonly COLOR_WARN="\033[1;33m"
readonly COLOR_ERROR="\033[0;31m"

# Function to log messages with a specific color and emoji
log() {
  local color="$1"
  local emoji="$2"
  local message="$3"
  echo -e "${color}[$(date +"%Y-%m-%d %H:%M:%S")] ${emoji} ${message}${COLOR_RESET}"
}

log_info() { log "${COLOR_INFO}" "ℹ️" "$1"; }
log_success() { log "${COLOR_SUCCESS}" "✅" "$1"; }
log_warn() { log "${COLOR_WARN}" "⚠️" "$1"; }
log_error() { log "${COLOR_ERROR}" "❌" "$1"; }
# ------------------------------------

error_handler() {
  local exit_code=$1
  local line_no=$2
  local command_name=$3
  log_error "An error occurred on line $line_no."
  log_error "Exit Code: $exit_code"
  log_error "Command: $command_name"
  log_error "Note: The specific error message should be printed in the lines above this error."
  exit "$exit_code"
}

trap 'error_handler $? $LINENO "$BASH_COMMAND"' ERR

# --- Centralized Cleanup Hooks ---
cleanup_temp_files() {
    local temp_dir="/tmp/backupdata-$SERVICE_NAME"
    local temp_sql="/tmp/dump.sql"

    if [ -d "$temp_dir" ]; then
        rm -rf "$temp_dir"
    fi
    if [ -f "$temp_sql" ]; then
        rm -f "$temp_sql"
    fi
}

cleanup_on_error() {
    local exit_code=$1
    if [ "$exit_code" -ne 0 ]; then
        # Only clean up the file if the script failed (so we don't delete successful backups)
        if [ -n "$BACKUP_FILE_PATH" ] && [ -f "$BACKUP_FILE_PATH" ]; then
            rm -f "$BACKUP_FILE_PATH"
        fi
    fi
}

master_cleanup_hook() {
    local exit_code=$?
    
    # Run the unconditional temp file cleanup
    cleanup_temp_files
    
    # Pass the captured exit code to the conditional error cleanup
    cleanup_on_error "$exit_code"
}

trap master_cleanup_hook EXIT

ODOO_DATABASE_NAME_PRD=$(grep "^DB_NAME=" "$PATH_TO_ODOO/.env" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')
ZIP_FILE_NAME=backupdata-$SERVICE_NAME.zip
BACKUP_FILE_PATH="/tmp/$ZIP_FILE_NAME"

# Check for zip utility
if ! command -v zip &> /dev/null; then
  log_error "zip command could not be found. Please install zip first."
  echo "For Ubuntu: sudo apt install zip"
  echo "For CentOS: sudo yum install zip"
  exit 1
fi

# Self-elevate to root if not already
if [ "$(id -u)" -ne 0 ]; then
    log_info "Elevating permissions to root..."
    # shellcheck disable=SC2093
    exec sudo "$0" "$@" # Re-run the script with sudo
    log_error "Failed to elevate to root. Please run with sudo." # This will only run if exec fails
    exit 1
fi

if [ -z "$ODOO_DATABASE_NAME_PRD" ]; then
  read -rp "Enter the database name: " ODOO_DATABASE_NAME_PRD
fi

ODOO_FILESTORE_PATH="/var/lib/odoo/$SERVICE_NAME/filestore/$ODOO_DATABASE_NAME_PRD"

log_info "Start backup data for $SERVICE_NAME"

if [ -f "$BACKUP_FILE_PATH" ]; then
    log_warn "Backup file already exists. Removing it..."
    rm -f "$BACKUP_FILE_PATH"
fi

log_info "Change Directory to $PATH_TO_ODOO"
cd "$PATH_TO_ODOO" > /dev/null 2>&1 || { log_error "Can't change directory to $PATH_TO_ODOO"; exit 1; }

log_info "Create temporary directory"
mkdir -p "/tmp/backupdata-$SERVICE_NAME" > /dev/null 2>&1 || { log_warn "/tmp/backupdata-$SERVICE_NAME may already exist."; true; }

log_info "Backup database $ODOO_DATABASE_NAME_PRD"
sudo -u postgres pg_dump -f "/tmp/dump.sql" "$ODOO_DATABASE_NAME_PRD" > /dev/null 2>&1 || { log_error "Error backup database $ODOO_DATABASE_NAME_PRD"; exit 1; }
mv /tmp/dump.sql "/tmp/backupdata-$SERVICE_NAME/dump.sql" > /dev/null 2>&1 || { log_error "Error moving dump.sql to /tmp/backupdata-$SERVICE_NAME"; exit 1; }

log_info "Copy filestore files to temporary directory"
cp -r "$ODOO_FILESTORE_PATH" "/tmp/backupdata-$SERVICE_NAME/filestore" > /dev/null 2>&1 || { log_error "Error copying filestore to /tmp/backupdata-$SERVICE_NAME"; exit 1; }

if [ -f "git/git_hashes.txt" ]; then
  log_info "Copy git_hashes.txt to temporary directory"
  cp -r git/git_hashes.txt "/tmp/backupdata-$SERVICE_NAME/git_hashes.txt" > /dev/null 2>&1 || { log_error "Error copying git_hashes.txt to /tmp/backupdata-$SERVICE_NAME"; exit 1; }
fi

if [ -f "odoo-base/git_hashes.txt" ]; then
  log_info "Copy odoo-base/git_hashes.txt to temporary directory"
  cp -r odoo-base/git_hashes.txt "/tmp/backupdata-$SERVICE_NAME/odoo-base_git_hashes.txt" > /dev/null 2>&1 || { log_error "Error copying odoo-base/git_hashes.txt to /tmp/backupdata-$SERVICE_NAME"; exit 1; }
fi

log_info "Change Directory to /tmp/backupdata-$SERVICE_NAME"
cd "/tmp/backupdata-$SERVICE_NAME" > /dev/null 2>&1 || { log_error "Can't change directory to /tmp/backupdata-$SERVICE_NAME"; exit 1; }

log_info "Compress all files to $ZIP_FILE_NAME"
zip -r "$BACKUP_FILE_PATH" ./dump.sql filestore ./git_hashes.txt ./odoo-base_git_hashes.txt > /dev/null 2>&1 || { log_error "Error compressing files to $BACKUP_FILE_PATH"; exit 1; }
chown "$SUDO_USER:$SUDO_USER" "$BACKUP_FILE_PATH"

log_success "Backup data for $SERVICE_NAME is completed. The backup file is located at $BACKUP_FILE_PATH."
exit 0
