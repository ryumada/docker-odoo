#!/usr/bin/env bash
set -e
# Category: Utility
# Description: Clones an Odoo database to another environment via the web endpoint.
# Usage: ./scripts/databasecloner.sh
# Dependencies: curl, docker, sudo, git

# Detect Repository Owner to run non-root commands as that user
CURRENT_DIR=$(dirname "$(readlink -f "$0")")
CURRENT_DIR_USER=$(stat -c '%U' "$CURRENT_DIR")
PATH_TO_ODOO=$(sudo -u "$CURRENT_DIR_USER" git -C "$(dirname "$(readlink -f "$0")")" rev-parse --show-toplevel)
SERVICE_NAME=$(basename "$PATH_TO_ODOO")
REPOSITORY_OWNER=$(stat -c '%U' "$PATH_TO_ODOO")

# Configuration
ENV_FILE=".env"
UPDATE_SCRIPT="./scripts/update-env-file.sh"
MAX_BACKUPS=3

# --- Logging Functions & Colors ---
# Define colors for log messages
readonly COLOR_RESET="\033[0m"
readonly COLOR_INFO="\033[0;34m"
readonly COLOR_SUCCESS="\033[0;32m"
readonly COLOR_WARN="\033[1;33m"
readonly COLOR_ERROR="\033[0;31m"

# Function to log messages with a specific color and emoji
log() {
  local color="$1"
  local emoji="$2"
  local message="$3"
  echo -e "${color}[$(date +"%Y-%m-%d %H:%M:%S")] ${emoji} ${message}${COLOR_RESET}"
}

log_info() { log "${COLOR_INFO}" "ℹ️" "$1"; }
log_success() { log "${COLOR_SUCCESS}" "✅" "$1"; }
log_warn() { log "${COLOR_WARN}" "⚠️" "$1"; }
log_error() { log "${COLOR_ERROR}" "❌" "$1"; }
# ------------------------------------

function checkOdooEndpoint() {
  local port="$1"
  log_info "Checking if Odoo endpoint is accessible on port $port..."

  if curl --output /dev/null --silent --head --fail "http://localhost:$port"; then
    log_success "Odoo endpoint is accessible on port $port."
    return 0
  else
    log_warn "Odoo endpoint is NOT accessible at http://localhost:$port. Retrying with longer timeout..."
    if curl --output /dev/null --silent --head --fail --connect-timeout 10 "http://localhost:$port"; then
      log_success "Odoo endpoint is accessible on port $port after retry."
      return 0
    else
      log_error "Odoo endpoint is NOT accessible at http://localhost:$port. Please check if the service is running."
      exit 1
    fi
  fi
}

error_handler() {
  local exit_code=$1
  local line_no=$2
  local command_name=$3
  log_error "An error occurred on line $line_no."
  log_error "Exit Code: $exit_code"
  log_error "Command: $command_name"
  log_error "Note: The specific error message should be printed in the lines above this error."
  exit "$exit_code"
}

trap 'error_handler $? $LINENO "$BASH_COMMAND"' ERR

# --- Centralized Cleanup Hook ---
cleanup_temp_files() {
    if [ -n "$TEMP_BACKUP_FILE" ] && [ -f "$TEMP_BACKUP_FILE" ]; then
        rm -f "$TEMP_BACKUP_FILE"
    fi
}
trap cleanup_temp_files EXIT

function promptWhichEnvironment() {
  local environment="$1"
  local ODOO_DEPLOYMENT_ENVIRONMENT
  local input_env

  if [ "$environment" == "" ]; then
    # You need to choose whether there are multiple environments for your deployment
    while true; do
      read -rp "Which environment you wish to clone the data to?
      [1] Development (dev)
      [2] Staging (stg)
      [3] Testing (tst)
      [4] Other

      Enter the number 1 - 4: " input_env

      if [[ ! "$input_env" =~ ^[1-9]+$ ]]; then
        log_error "Invalid input. Please enter a number base on the menu above."
        continue
      fi

      case $input_env in
        1)
          ODOO_DEPLOYMENT_ENVIRONMENT=dev
          break
          ;;
        2)
          ODOO_DEPLOYMENT_ENVIRONMENT=stg
          break
          ;;
        3)
          ODOO_DEPLOYMENT_ENVIRONMENT=tst
          break
          ;;
        4)
          read -rp "Enter the environment name: " ODOO_DEPLOYMENT_ENVIRONMENT
          break
          ;;
        *)
          log_error "Invalid option"
          ;;
      esac
    done
  else
    ODOO_DEPLOYMENT_ENVIRONMENT=$environment
  fi

  echo "$ODOO_DEPLOYMENT_ENVIRONMENT"
}

function get_next_prefix() {
  local env_file="$1"
  local current_count
  local next_count

  # Read existing count
  current_count=$(grep "^DB_PREFIX_COUNT=" "$env_file" | cut -d "=" -f 2 | tr -d '[:space:]')

  # Initialize if empty or not a number
  if [[ ! "$current_count" =~ ^[0-9]+$ ]]; then
    current_count=-1
  fi

  # Increment
  next_count=$((current_count + 1))

  # Reset if > 999
  if [ "$next_count" -gt 999 ]; then
    next_count=0
  fi

  # Update .env file
  if grep -q "^DB_PREFIX_COUNT=" "$env_file"; then
     sed -i "s/^DB_PREFIX_COUNT=.*/DB_PREFIX_COUNT=$next_count/" "$env_file"
  else
     echo "DB_PREFIX_COUNT=$next_count" >> "$env_file"
  fi

  # Output formatted with leading zeros
  printf "%03d" "$next_count"
}

function promptClonedDBName() {
  local env_file="$1"
  local use_date_suffix="$2"
  local ODOO_DEPLOYMENT_ENVIRONMENT="$3"
  local ODOO_DB_NAME_ENV
  local DB_PREFIX
  DB_PREFIX=$(get_next_prefix "$env_file")
  local USE_DATE_SUFFIX_INPUT

  case "$use_date_suffix" in
    Y|y)
      ODOO_DB_NAME_ENV="$DB_PREFIX-$ODOO_DEPLOYMENT_ENVIRONMENT-$(date +"%Y%m%d_%H%M")"
      ;;
    prompt)
      while true; do
        read -rp "Do you want to use a date suffix for the new database name? [Y/n]: " USE_DATE_SUFFIX_INPUT

        case "$USE_DATE_SUFFIX_INPUT" in
          Y|y)
            ODOO_DB_NAME_ENV="$DB_PREFIX-$ODOO_DEPLOYMENT_ENVIRONMENT-$(date +"%Y%m%d_%H%M")"; break ;;
          N|n)
            ODOO_DB_NAME_ENV="$DB_PREFIX-$ODOO_DEPLOYMENT_ENVIRONMENT"; break ;;
          *)
            log_error "Invalid option" ;;
        esac
      done
      ;;
    *)
      ODOO_DB_NAME_ENV="$DB_PREFIX-$ODOO_DEPLOYMENT_ENVIRONMENT"
      ;;
  esac

  echo "$ODOO_DB_NAME_ENV"
}

function main() {
  # Self-elevate to root if not already
  if [ "$(id -u)" -ne 0 ]; then
      log_info "Elevating permissions to root..."
      # shellcheck disable=SC2093
      exec sudo "$0" "$@" # Re-run the script with sudo
      log_error "Failed to elevate to root. Please run with sudo." # This will only run if exec fails
      exit 1
  fi

  TEMP_BACKUP_FILE="/tmp/cloner_backup-$SERVICE_NAME.zip"
  ENV_FILE="$PATH_TO_ODOO/.env"

  # Source environment details
  SOURCE_ADMIN_PASSWD=$(grep "^ADMIN_PASSWD=" "$ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')
  SOURCE_PORT=$(grep "^PORT=" "$ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')

  ODOO_DATABASE_NAME_PRD=$(grep "^DB_NAME=" "$ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')
  if [ -z "$ODOO_DATABASE_NAME_PRD" ]; then
    read -rp "Enter the database name: " ODOO_DATABASE_NAME_PRD
  fi

  ## The environment to which the database will be cloned (leave empty to prompt)
  CLONED_ENV=$(grep "^CLONED_ENV=" "$ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')

  ## ex. Y (replace with Y if you want to use a date suffix for the new database name)
  # This variable determines whether to use a date suffix for the new database name
  USE_DATE_SUFFIX=$(grep "^USE_DATE_SUFFIX=" "$ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')

  ODOO_DEPLOYMENT_ENVIRONMENT=$(promptWhichEnvironment "$CLONED_ENV")

  PATH_TO_ODOO_ENV="$PATH_TO_ODOO/../$SERVICE_NAME-$ODOO_DEPLOYMENT_ENVIRONMENT"

  if [ ! -d "$PATH_TO_ODOO_ENV" ]; then
    log_error "The destination deployment environment '$SERVICE_NAME-$ODOO_DEPLOYMENT_ENVIRONMENT' does not exist at '$PATH_TO_ODOO_ENV'"
    exit 1
  fi

  # Destination environment details
  DEST_ADMIN_PASSWD=$(grep "^ADMIN_PASSWD=" "$PATH_TO_ODOO_ENV/.env" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')
  DEST_PORT=$(grep "^PORT=" "$PATH_TO_ODOO_ENV/.env" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')

  if [ -z "$SOURCE_ADMIN_PASSWD" ] || [ -z "$SOURCE_PORT" ] || [ -z "$DEST_ADMIN_PASSWD" ] || [ -z "$DEST_PORT" ]; then
    log_error "ADMIN_PASSWD and/or PORT not set in the .env file of the source or destination environment."
    exit 1
  fi

  ODOO_DB_NAME_ENV=$(promptClonedDBName "$ENV_FILE" "$USE_DATE_SUFFIX" "$ODOO_DEPLOYMENT_ENVIRONMENT")

  log_info "Start cloning database from '$ODOO_DATABASE_NAME_PRD' to '$ODOO_DB_NAME_ENV'"

  # 1. Backup source database using curl
  # Check Source Health
  log_info "Checking Source ($SERVICE_NAME) Health..."
  checkOdooEndpoint "$SOURCE_PORT"

  log_info "Requesting backup from source Odoo instance..."
  curl -s -X POST \
       -F "master_pwd=$SOURCE_ADMIN_PASSWD" \
       -F "name=$ODOO_DATABASE_NAME_PRD" \
       -F "backup_format=zip" \
       -o "$TEMP_BACKUP_FILE" \
       "http://localhost:$SOURCE_PORT/web/database/backup"

  if [ ! -s "$TEMP_BACKUP_FILE" ]; then
      log_error "Backup failed. The output file is empty or was not created. Check source Odoo logs."
      exit 1
  fi
  log_success "Backup of '$ODOO_DATABASE_NAME_PRD' completed successfully to $TEMP_BACKUP_FILE"

  # 2. Restore to destination database using curl
  log_info "Ensuring the destination environment '$ODOO_DEPLOYMENT_ENVIRONMENT' is running before restore..."
  if ! docker compose -f "$PATH_TO_ODOO_ENV/docker-compose.yml" up -d > /dev/null 2>&1; then
    log_warn "Could not start destination environment. It might already be running or there could be an issue."
  fi

  # Check Destination Health
  log_info "Checking Destination ($SERVICE_NAME-$ODOO_DEPLOYMENT_ENVIRONMENT) Health..."
  checkOdooEndpoint "$DEST_PORT"

  log_info "Dropping old database '$ODOO_DB_NAME_ENV' if it exists..."
  drop_response=$(curl -s -X POST \
    -d "master_pwd=$DEST_ADMIN_PASSWD" \
    -d "name=$ODOO_DB_NAME_ENV" \
    "http://localhost:$DEST_PORT/web/database/drop")

  drop_response_lower="${drop_response,,}"

  if [[ "$drop_response_lower" == *"error"* ]] && [[ "$drop_response_lower" != *"does not exist"* ]] || \
     [[ "$drop_response_lower" == *"no space left"* ]] || \
     [[ "$drop_response_lower" == *"<html"* ]]; then
      log_warn "Could not drop database '$ODOO_DB_NAME_ENV'. It might not exist or another error occurred. Response: $drop_response"
  else
      log_info "Drop database command sent for '$ODOO_DB_NAME_ENV'."
  fi

  # restore the database
  NEUTRALIZE_DB=$(grep "^NEUTRALIZE_DATABASE=" "$PATH_TO_ODOO_ENV/.env" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')
  if [ -z "$NEUTRALIZE_DB" ]; then
      NEUTRALIZE_DB="true"
  fi

  log_info "Requesting restore to destination Odoo instance..."
  log_info "Neutralize database option: $NEUTRALIZE_DB"

  if [ "$NEUTRALIZE_DB" = "true" ]; then
    response=$(curl -s -X POST \
      -F "master_pwd=$DEST_ADMIN_PASSWD" \
      -F "name=$ODOO_DB_NAME_ENV" \
      -F "backup_file=@$TEMP_BACKUP_FILE" \
      -F "copy=true" \
      -F "neutralize_database=true" \
      "http://localhost:$DEST_PORT/web/database/restore")
  else
    response=$(curl -s -X POST \
      -F "master_pwd=$DEST_ADMIN_PASSWD" \
      -F "name=$ODOO_DB_NAME_ENV" \
      -F "backup_file=@$TEMP_BACKUP_FILE" \
      -F "copy=true" \
      "http://localhost:$DEST_PORT/web/database/restore")
  fi

  response_lower="${response,,}"

  if [[ "$response_lower" == *"error"* ]] || \
     [[ "$response_lower" == *"incorrect master password"* ]] || \
     [[ "$response_lower" == *"no space left"* ]] || \
     [[ "$response_lower" == *"<html"* ]] || \
     [ -z "$response" ]; then
    log_error "Failed to restore database to destination. Response: ${response:-'Empty response (Likely timeout or bad gateway)'}"
    exit 1
  fi

  log_success "Database restore command sent successfully to destination."

  log_info "Restarting the destination environment '$ODOO_DEPLOYMENT_ENVIRONMENT'..."
  docker compose -f "$PATH_TO_ODOO_ENV/docker-compose.yml" up -d > /dev/null 2>&1 || { log_error "Error restarting $ODOO_DEPLOYMENT_ENVIRONMENT"; exit 1; }

  log_success "Finish cloning database '$ODOO_DB_NAME_ENV' from '$ODOO_DATABASE_NAME_PRD'"
}

main "$@"
