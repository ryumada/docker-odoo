#!/bin/bash

# Exit immediately if a command exits with a non-zero status
set -e

# --- Logging Functions & Colors ---
readonly COLOR_RESET="\033[0m"
readonly COLOR_INFO="\033[0;34m"
readonly COLOR_SUCCESS="\033[0;32m"
readonly COLOR_WARN="\033[0;33m"
readonly COLOR_ERROR="\033[0;31m"
readonly COLOR_CYAN="\033[0;36m"

log() {
    local color="$1"
    local emoji="$2"
    local message="$3"
    echo -e "${color}[$(date +"%Y-%m-%d %H:%M:%S")] ${emoji} ${message}${COLOR_RESET}"
}

log_info() { log "${COLOR_INFO}" "‚ÑπÔ∏è" "$1"; }
log_success() { log "${COLOR_SUCCESS}" "‚úÖ" "$1"; }
log_warn() { log "${COLOR_WARN}" "‚ö†Ô∏è" "$1"; }
log_error() { log "${COLOR_ERROR}" "‚ùå" "$1"; }
log_stage() { log "${COLOR_CYAN}" "üìã" "$1"; }
# ------------------------------------

# Self-elevate to root if not already
if [ "$(id -u)" -ne 0 ]; then
    log_info "Elevating permissions to root..."
    exec sudo "$0" "$@"
    log_error "Failed to elevate to root. Please run with sudo."
    exit 1
fi

# --- Usage / Help Function ---
display_usage() {
    echo -e "${COLOR_INFO}Usage:${COLOR_RESET} sudo $0 <REPO_NAME> <BRANCH> <RENEW_DB> [MODULES]"
    echo ""
    echo -e "${COLOR_CYAN}Examples:${COLOR_RESET}"
    echo "  sudo $0 odoo-custom release/feature_a false"
    echo "  sudo $0 odoo-custom release/feature_a true"
    echo "  sudo $0 odoo-custom release/feature_a false sale,stock"
    echo ""
}

if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    display_usage
    exit 0
fi

# --- Inputs ---
GIT_REPO_NAME=$1
RELEASE_BRANCH=$2
IS_RENEW_DB=$3
MODULES_TO_UPDATE=$4

# --- Input Validation ---
if [ -z "$GIT_REPO_NAME" ] || [ -z "$RELEASE_BRANCH" ] || [ -z "$IS_RENEW_DB" ]; then
    log_error "Missing arguments."
    display_usage
    exit 1
fi

case "${IS_RENEW_DB}" in
    1|true|True|TRUE) IS_RENEW_DB=true ;;
    *) IS_RENEW_DB=false ;;
esac

# --- Dynamic Path Definition ---
CURRENT_DIR=$(dirname "$(readlink -f "$0")")
CURRENT_DIR_USER=$(stat -c '%U' "$CURRENT_DIR")
STG_PATH_TO_ODOO=$(sudo -u "$CURRENT_DIR_USER" git -C "$(dirname "$(readlink -f "$0")")" rev-parse --show-toplevel)
SERVICE_NAME=$(basename "$STG_PATH_TO_ODOO")
SERVICE_NAME_PRD=${SERVICE_NAME%%-*} # Assumes format like 'project-stg' -> 'project'

# Load Staging Env
STG_ENV_FILE="$STG_PATH_TO_ODOO/.env"
STG_DB_NAME_FROM_ENV=$(grep "^DB_NAME=" "$STG_ENV_FILE" | cut -d "=" -f 2 | tr -d '[:space:]')
STG_DB_NAME="$STG_DB_NAME_FROM_ENV"

# Fallback DB Name
if [ -z "$STG_DB_NAME" ]; then
    STG_DB_NAME="$SERVICE_NAME-$(date +"%Y%m%d-%H%M%S")"
fi

STG_GIT_PATH="$STG_PATH_TO_ODOO/git/$GIT_REPO_NAME"

if [ ! -d "$STG_GIT_PATH" ]; then
    log_error "Git path not found at: $STG_GIT_PATH"
    exit 1
fi

log_info "üöÄ Starting Deployment for Service: $SERVICE_NAME"
log_info "   Git Repo: $GIT_REPO_NAME"
log_info "   Branch:   $RELEASE_BRANCH"
log_info "   Renew DB: $IS_RENEW_DB"

# =========================================================
# 1. SWITCH BRANCH (Code Update)
# =========================================================
log_stage "[1/4] Switching Git Branch..."

if sudo -u "$CURRENT_DIR_USER" git -C "$STG_GIT_PATH" fetch; then
    log_info "Fetch success."
else
    log_error "Failed to fetch."
    exit 1
fi

# Reset hard to discard local changes in staging
sudo -u "$CURRENT_DIR_USER" git -C "$STG_GIT_PATH" reset --hard > /dev/null

if sudo -u "$CURRENT_DIR_USER" git -C "$STG_GIT_PATH" checkout "$RELEASE_BRANCH"; then
    log_success "Checked out branch: $RELEASE_BRANCH"
else
    log_error "Failed to checkout branch $RELEASE_BRANCH."
    exit 1
fi

if sudo -u "$CURRENT_DIR_USER" git -C "$STG_GIT_PATH" pull; then
    log_success "Code is up to date."
else
    log_error "Failed to pull latest code."
    exit 1
fi

# =========================================================
# 2. CLONE DATABASE (Manual Dump/Restore)
# =========================================================
if [ "$IS_RENEW_DB" == "true" ]; then
    log_stage "[2/4] Cloning Production Database to Staging..."

    # Define Prod Paths
    PRD_PATH_TO_ODOO="$STG_PATH_TO_ODOO/../$SERVICE_NAME_PRD"
    PRD_ENV_FILE="$PRD_PATH_TO_ODOO/.env"

    if [ ! -f "$PRD_ENV_FILE" ]; then
        log_error "Production .env file not found at: $PRD_ENV_FILE"
        exit 1
    fi

    PRD_DB_NAME=$(grep "^DB_NAME=" "$PRD_ENV_FILE" | cut -d "=" -f 2 | tr -d '[:space:]')

    if [ -z "$PRD_DB_NAME" ]; then
        log_error "DB_NAME is not set in Production .env"
        exit 1
    fi

    # Determine DB User for Staging (for ownership)
    # Check secrets file first (like reference script), then env, then default 'odoo'
    if [ -f "$STG_PATH_TO_ODOO/.secrets/db_user" ]; then
        STG_DB_USER=$(cat "$STG_PATH_TO_ODOO/.secrets/db_user")
    else
        STG_DB_USER=$(grep "^DB_USER=" "$STG_ENV_FILE" | cut -d "=" -f 2 | tr -d '[:space:]')
        if [ -z "$STG_DB_USER" ]; then STG_DB_USER="odoo"; fi
    fi

    # Define Filestore Paths
    # Assumes standard Odoo Docker volume location: /var/lib/odoo/<service_name>/filestore/<db_name>
    PRD_FILESTORE_PATH="/var/lib/odoo/$SERVICE_NAME_PRD/filestore/$PRD_DB_NAME"
    STG_FILESTORE_PATH="/var/lib/odoo/$SERVICE_NAME/filestore/$STG_DB_NAME"

    DUMP_FILE="/tmp/${STG_DB_NAME}_clone.sql"
    log_info "Dumping Production DB ($PRD_DB_NAME) to $DUMP_FILE..."
    if sudo -u postgres pg_dump -d "$PRD_DB_NAME" -f "$DUMP_FILE"; then
        log_success "Dump created."
    else
        log_error "Failed to dump production database. Check postgres permissions or DB name."
        exit 1
    fi

    log_info "Syncing Filestore..."
    if [ -d "$STG_FILESTORE_PATH" ]; then
        rm -rf "$STG_FILESTORE_PATH"
    fi
    mkdir -p "$STG_FILESTORE_PATH"

    # Use rsync to copy data
    if rsync -a "$PRD_FILESTORE_PATH/" "$STG_FILESTORE_PATH"; then
        log_success "Filestore copied."
        # Fix ownership
        chown -R odoo: "$STG_FILESTORE_PATH"
    else
        log_error "Failed to rsync filestore from $PRD_FILESTORE_PATH"
        exit 1
    fi

    log_info "Stopping Staging container to release DB locks..."
    cd "$STG_PATH_TO_ODOO"
    docker compose stop odoo

    log_info "Dropping and Recreating Database ($STG_DB_NAME)..."

    # Drop (Force disconnects if necessary, though container stop usually suffices)
    sudo -u postgres psql -d postgres -c "DROP DATABASE IF EXISTS \"$STG_DB_NAME\" WITH (FORCE)" > /dev/null

    # Create
    if sudo -u postgres psql -d postgres -c "CREATE DATABASE \"$STG_DB_NAME\""; then
        log_success "Database created."
    else
        log_error "Failed to create database."
        exit 1
    fi

    log_info "Restoring Dump into Staging..."
    if sudo -u postgres psql -d "$STG_DB_NAME" -f "$DUMP_FILE" > /dev/null; then
        log_success "Restore complete."
        rm -f "$DUMP_FILE"
    else
        log_error "Failed to restore SQL dump."
        rm -f "$DUMP_FILE"
        exit 1
    fi

    log_info "Sanitizing the database (Disabling Emails & Crons)"

    # 1. Disable Crons and Emails (Important for Staging)
    # SQL commands to disable outgoing email, crons, and mail servers
    NEUTRALIZE_DB=$(grep "^NEUTRALIZE_DATABASE=" "$STG_ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')
    if [ -z "$NEUTRALIZE_DB" ]; then
        NEUTRALIZE_DB="true"
    fi

    if [ "$NEUTRALIZE_DB" = "true" ]; then
        SANITIZE_SQL="
            -- Disable all Outgoing Mail Servers
            UPDATE ir_mail_server SET active = false;

            -- Disable specific email-related cron jobs
            UPDATE ir_cron SET active = false;

            -- Set System Parameter to prevent catching emails
            DELETE FROM ir_config_parameter WHERE key = 'mail.catchall.domain';
            INSERT INTO ir_config_parameter (key, value) VALUES ('mail.catchall.domain', 'localhost');
        "

        # Execute the SQL commands
        # Using || true to prevent script exit if a minor sql error occurs, but verifying execution via check
        if sudo -u postgres psql -d "$STG_DB_NAME" -c "$SANITIZE_SQL" > /dev/null 2>&1; then
            log_success "Database sanitized successfully."
        else
            log_warn "Warning: Failed to sanitize database completely (SQL command failed)."
        fi
    fi

    # 2. Fix Ownership
    log_info "Fixing DB Object Ownership to user: $STG_DB_USER"

    sudo -u postgres psql -d postgres -c "ALTER DATABASE \"$STG_DB_NAME\" OWNER TO \"$STG_DB_USER\"" > /dev/null

    # Run the PL/pgSQL block to fix tables, sequences, and views
    sudo -u postgres psql -d "$STG_DB_NAME" -c "
        DO \$\$
        DECLARE
            rec RECORD;
        BEGIN
            -- Tables
            FOR rec IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
                EXECUTE 'ALTER TABLE ' || quote_ident(rec.tablename) || ' OWNER TO \"${STG_DB_USER}\"';
            END LOOP;
            -- Sequences
            FOR rec IN (SELECT sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public') LOOP
                EXECUTE 'ALTER SEQUENCE ' || quote_ident(rec.sequence_name) || ' OWNER TO \"${STG_DB_USER}\"';
            END LOOP;
            -- Views
            FOR rec IN (SELECT table_name FROM information_schema.views WHERE table_schema = 'public') LOOP
                EXECUTE 'ALTER VIEW ' || quote_ident(rec.table_name) || ' OWNER TO \"${STG_DB_USER}\"';
            END LOOP;
        END \$\$;
    " > /dev/null 2>&1 || log_warn "Ownership fix script had minor issues, but proceeding."

else
    log_stage "[2/4] Skipping Database Clone (IS_RENEW_DB is false)."
fi

# =========================================================
# 3. RESTART CONTAINER
# =========================================================
log_stage "[3/4] Restarting Staging Container..."

cd "$STG_PATH_TO_ODOO"
# Using up -d --force-recreate ensures clean start if it was stopped
if docker compose up -d --force-recreate odoo; then
    log_success "Container restarted."
else
    log_error "Failed to restart docker container."
    exit 1
fi

# =========================================================
# 4. UPDATE MODULES
# =========================================================
if [ -z "$MODULES_TO_UPDATE" ]; then
    log_stage "[4/4] Update module skipped..."
    log_warn "No specific modules listed."
else
    log_stage "[4/4] Updating Odoo Modules..."
    log_info "Waiting 10 seconds for Odoo to initialize..."
    sleep 10
    log_info "Updating modules: $MODULES_TO_UPDATE"

    if docker compose exec odoo odoo-module-upgrade "$STG_DB_NAME" --update="$MODULES_TO_UPDATE"; then
        log_success "Modules updated successfully."
    else
        log_error "Failed to update modules."
        exit 1
    fi
fi

echo ""
echo "=================================================="
log_success "Deployment Complete!"
echo "   Service:     $SERVICE_NAME"
if [ "$IS_RENEW_DB" == "true" ]; then
    echo "   Database:    $STG_DB_NAME (Cloned from $PRD_DB_NAME)"
fi
echo "   Branch:      $RELEASE_BRANCH"
echo "=================================================="
