#!/bin/bash

# Exit immediately if a command exits with a non-zero status
set -e

# --- Logging Functions & Colors ---
# Define colors for log messages
readonly COLOR_RESET="\033[0m"
readonly COLOR_INFO="\033[0;34m"
readonly COLOR_SUCCESS="\033[0;32m"
readonly COLOR_WARN="\033[0;33m"
readonly COLOR_ERROR="\033[0;31m"
readonly COLOR_CYAN="\033[0;36m"

# Function to log messages with a specific color and emoji
log() {
    local color="$1"
    local emoji="$2"
    local message="$3"
    if [ "$JSON_MODE" = "true" ]; then
        echo -e "${color}[$(date +"%Y-%m-%d %H:%M:%S")] ${emoji} ${message}${COLOR_RESET}" >&2
    else
        echo -e "${color}[$(date +"%Y-%m-%d %H:%M:%S")] ${emoji} ${message}${COLOR_RESET}"
    fi
}

log_info() { log "${COLOR_INFO}" "‚ÑπÔ∏è" "$1"; }
log_success() { log "${COLOR_SUCCESS}" "‚úÖ" "$1"; }
log_warn() { log "${COLOR_WARN}" "‚ö†Ô∏è" "$1"; }
log_error() { log "${COLOR_ERROR}" "‚ùå" "$1"; }
log_stage() { log "${COLOR_CYAN}" "üìã" "$1"; }
# ------------------------------------

# Self-elevate to root if not already
if [ "$(id -u)" -ne 0 ]; then
    log_info "Elevating permissions to root..."
    # shellcheck disable=SC2093
    exec sudo "$0" "$@" # Re-run the script with sudo
    log_error "Failed to elevate to root. Please run with sudo." # This will only run if exec fails
    exit 1
fi

# --- JSON Mode Detection ---
JSON_MODE="false"
# Filter 'json' from arguments
ARGS=()
for arg in "$@"; do
    if [[ "$arg" == "json" ]]; then
        JSON_MODE="true"
    else
        ARGS+=("$arg")
    fi
done
set -- "${ARGS[@]}"

# --- Usage / Help Function ---
display_usage() {
    echo -e "${COLOR_INFO}Usage:${COLOR_RESET} sudo $0 <REPO_NAME> <BRANCH> <RENEW_DB> [MODULES]"
    echo ""
    echo -e "${COLOR_CYAN}Arguments:${COLOR_RESET}"
    echo -e "  ${COLOR_SUCCESS}1. REPO_NAME${COLOR_RESET}       : The directory name of the git repository (inside stg/git/)."
    echo -e "  ${COLOR_SUCCESS}2. BRANCH${COLOR_RESET}          : The target Git branch to checkout (e.g., 'staging', 'main')."
    echo -e "  ${COLOR_SUCCESS}3. RENEW_DB${COLOR_RESET}        : Set to 'true' or '1' to drop Staging DB and clone from Production."
    echo -e "                       Set to 'false' or '0' to keep existing Staging data."
    echo -e "  ${COLOR_SUCCESS}4. MODULES${COLOR_RESET}         : (Optional) Comma-separated list of modules to update (e.g., 'sale,stock')."
    echo ""
    echo -e "${COLOR_CYAN}Examples:${COLOR_RESET}"
    echo "  # 1. Update code only (Fastest):"
    echo "  sudo $0 odoo-custom release/feature_a false"
    echo ""
    echo "  # 2. Update code and refresh Database from Prod (Full Reset):"
    echo "  sudo $0 odoo-custom release/feature_a true"
    echo ""
    echo "  # 3. Update code and specific modules without DB reset:"
    echo "  sudo $0 odoo-custom release/feature_a false sale,inventory,account"
    echo ""
}

# --- Check for Help Flag ---
if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    display_usage
    exit 0
fi

# --- Inputs ---
GIT_REPO_NAME=$1
RELEASE_BRANCH=$2
IS_RENEW_DB=$3
MODULES_TO_UPDATE=$4

# --- Validation ---
MISSING_ARGS=false
if [ -z "$GIT_REPO_NAME" ]; then
    log_error "Missing Argument 1: Git Repo Name"
    MISSING_ARGS=true
fi

if [ -z "$RELEASE_BRANCH" ]; then
    log_error "Missing Argument 2: Release Branch"
    MISSING_ARGS=true
fi

if [ -z "$IS_RENEW_DB" ]; then
    log_error "Missing Argument 3: Clone DB Flag (true/false)"
    MISSING_ARGS=true
fi

if [ "$MISSING_ARGS" == "true" ]; then
    echo ""
    display_usage
    exit 1
fi

# --- Dynamic Path Definition ---
CURRENT_DIR=$(dirname "$(readlink -f "$0")")
CURRENT_DIR_USER=$(stat -c '%U' "$CURRENT_DIR")
STG_PATH_TO_ODOO=$(sudo -u "$CURRENT_DIR_USER" git -C "$(dirname "$(readlink -f "$0")")" rev-parse --show-toplevel)
SERVICE_NAME=$(basename "$STG_PATH_TO_ODOO")
SERVICE_NAME_PRD=${SERVICE_NAME%-*} # Assumes format like 'project-stg' -> 'project' OR 'project-16-stg' -> 'project-16'

# Try to grab this automatically from your .env file
STG_ENV_FILE="$STG_PATH_TO_ODOO/.env"
STG_DB_NAME_FROM_ENV=$(grep "^DB_NAME=" "$STG_ENV_FILE" | cut -d "=" -f 2 | tr -d '[:space:]')
STG_DB_NAME="$STG_DB_NAME_FROM_ENV"

# Fallback DB Name
if [ -z "$STG_DB_NAME" ]; then
    # Fallback if .env is empty
    STG_DB_NAME="$SERVICE_NAME-$(date +"%Y%m%d-%H%M%S")"
fi

case "${IS_RENEW_DB}" in
    1|true|True|TRUE)
        IS_RENEW_DB=true
    ;;
    *)
        IS_RENEW_DB=false
    ;;
esac

STG_GIT_PATH="$STG_PATH_TO_ODOO/git/$GIT_REPO_NAME"

# Verify Git path exists
if [ ! -d "$STG_GIT_PATH" ]; then
    log_error "Git path not found at: $STG_GIT_PATH"
    exit 1
fi

log_info "üöÄ Starting Deployment for Service: $SERVICE_NAME"
log_info "   Git Repo Name: $GIT_REPO_NAME"
log_info "   Branch: $RELEASE_BRANCH"
if [ "$IS_RENEW_DB" == "true" ]; then
    log_info "   Target DB: $STG_DB_NAME"
fi
log_info "   Clone DB: $IS_RENEW_DB"


# 1. SWITCH BRANCH (Code Update)
# ---------------------------------------------------------
log_stage "[1/4] Switching Git Branch..."

# Fetch updates
if [ "$JSON_MODE" = "true" ]; then
    GIT_FETCH_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH fetch >&2"
else
    GIT_FETCH_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH fetch"
fi

if eval "$GIT_FETCH_CMD"; then
    log_info "Fetch success."
else
    log_error "Failed to fetch."
    exit 1
fi

# Force checkout clean (discard local changes in staging)
if [ "$JSON_MODE" = "true" ]; then
    GIT_RESET_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH reset --hard >&2"
else
    GIT_RESET_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH reset --hard"
fi

if eval "$GIT_RESET_CMD"; then
    log_info "Local changes discarded (Reset Hard)."
else
    log_warn "Could not reset git changes. Proceeding..."
fi

if [ "$JSON_MODE" = "true" ]; then
    GIT_CHECKOUT_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH checkout $RELEASE_BRANCH >&2"
else
    GIT_CHECKOUT_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH checkout $RELEASE_BRANCH"
fi

if eval "$GIT_CHECKOUT_CMD"; then
    log_success "Checked out branch: $RELEASE_BRANCH"
else
    log_error "Failed to checkout branch $RELEASE_BRANCH. Does it exist?"
    exit 1
fi

if [ "$JSON_MODE" = "true" ]; then
    GIT_PULL_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH pull >&2"
else
    GIT_PULL_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH pull"
fi

if eval "$GIT_PULL_CMD"; then
    log_success "Code is up to date."
else
    log_error "Failed to pull latest code."
    exit 1
fi


# 2. CLONE DATABASE (Data Reset)
# ---------------------------------------------------------
if [ "$IS_RENEW_DB" == "true" ]; then
    PRD_PATH_TO_ODOO="$STG_PATH_TO_ODOO/../$SERVICE_NAME_PRD"
    PRD_ENV_FILE="$PRD_PATH_TO_ODOO/.env"

    if [ ! -f "$PRD_ENV_FILE" ]; then
        log_error "Production .env file not found at: $PRD_ENV_FILE"
        exit 1
    fi

    PRD_DB_NAME=$(grep "^DB_NAME=" "$PRD_ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')

    if [ -z "$PRD_DB_NAME" ]; then
        log_error "DB_NAME is not set in the production environment. Please set it at: $PRD_ENV_FILE"
        exit 1
    fi

    log_stage "[2/4] Cloning Production Database to Staging..."

    # Determine DB User for Staging (for ownership)
    # Check secrets file first (like reference script), then env, then default 'odoo'
    if [ -f "$STG_PATH_TO_ODOO/.secrets/db_user" ]; then
        STG_DB_USER=$(cat "$STG_PATH_TO_ODOO/.secrets/db_user")
    else
        STG_DB_USER=$(grep "^DB_USER=" "$STG_ENV_FILE" | cut -d "=" -f 2 | tr -d '[:space:]')
        if [ -z "$STG_DB_USER" ]; then STG_DB_USER="odoo"; fi
    fi

    # Define Filestore Paths
    # Assumes standard Odoo Docker volume location: /var/lib/odoo/<service_name>/filestore/<db_name>
    PRD_FILESTORE_PATH="/var/lib/odoo/$SERVICE_NAME_PRD/filestore/$PRD_DB_NAME"
    STG_FILESTORE_PATH="/var/lib/odoo/$SERVICE_NAME/filestore/$STG_DB_NAME"

    DUMP_FILE="/tmp/${STG_DB_NAME}_clone.sql"
    log_info "Dumping Production DB ($PRD_DB_NAME) to $DUMP_FILE..."
    if [ "$JSON_MODE" = "true" ]; then
        if sudo -u postgres pg_dump -d "$PRD_DB_NAME" -f "$DUMP_FILE" >&2; then
            log_success "Dump created."
        else
            log_error "Failed to dump production database. Check postgres permissions or DB name."
            exit 1
        fi
    else
        if sudo -u postgres pg_dump -d "$PRD_DB_NAME" -f "$DUMP_FILE"; then
            log_success "Dump created."
        else
            log_error "Failed to dump production database. Check postgres permissions or DB name."
            exit 1
        fi
    fi

    log_info "Syncing Filestore..."
    if [ -d "$STG_FILESTORE_PATH" ]; then
        rm -rf "$STG_FILESTORE_PATH"
    fi
    mkdir -p "$STG_FILESTORE_PATH"

    # Use rsync to copy data
    if [ "$JSON_MODE" = "true" ]; then
        RSYNC_CMD="rsync -a $PRD_FILESTORE_PATH/ $STG_FILESTORE_PATH >&2"
    else
        RSYNC_CMD="rsync -a $PRD_FILESTORE_PATH/ $STG_FILESTORE_PATH"
    fi

    if eval "$RSYNC_CMD"; then
        log_success "Filestore copied."
        # Fix ownership
        chown -R odoo: "$STG_FILESTORE_PATH"
    else
        log_error "Failed to rsync filestore from $PRD_FILESTORE_PATH"
        exit 1
    fi

    log_info "Stopping Staging container to release DB locks..."
    cd "$STG_PATH_TO_ODOO"
    if [ "$JSON_MODE" = "true" ]; then
        docker compose stop odoo >&2
    else
        docker compose stop odoo
    fi

    log_info "Dropping and Recreating Database ($STG_DB_NAME)..."

    # Drop (Force disconnects if necessary, though container stop usually suffices)
    sudo -u postgres psql -d postgres -c "DROP DATABASE IF EXISTS \"$STG_DB_NAME\" WITH (FORCE)" > /dev/null

    # Create
    if [ "$JSON_MODE" = "true" ]; then
        if sudo -u postgres psql -d postgres -c "CREATE DATABASE \"$STG_DB_NAME\"" >&2; then
             log_success "Database created."
        else
             log_error "Failed to create database."
             exit 1
        fi
    else
        if sudo -u postgres psql -d postgres -c "CREATE DATABASE \"$STG_DB_NAME\""; then
             log_success "Database created."
        else
             log_error "Failed to create database."
             exit 1
        fi
    fi

    log_info "Restoring Dump into Staging..."
    if sudo -u postgres psql -d "$STG_DB_NAME" -f "$DUMP_FILE" > /dev/null; then
        log_success "Restore complete."
        rm -f "$DUMP_FILE"
    else
        log_error "Failed to restore SQL dump."
        rm -f "$DUMP_FILE"
        exit 1
    fi

    log_info "Sanitizing the database (Disabling Emails & Crons)"

    # 1. Disable Crons and Emails (Important for Staging)
    # SQL commands to disable outgoing email, crons, and mail servers
    NEUTRALIZE_DB=$(grep "^NEUTRALIZE_DATABASE=" "$PRD_ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')
    if [ -z "$NEUTRALIZE_DB" ]; then
        NEUTRALIZE_DB="true"
    fi

    if [ "$NEUTRALIZE_DB" = "true" ]; then
        SANITIZE_SQL="
            -- Disable all Outgoing Mail Servers
            UPDATE ir_mail_server SET active = false;

            -- Disable specific email-related cron jobs
            UPDATE ir_cron SET active = false;

            -- Set System Parameter to prevent catching emails
            DELETE FROM ir_config_parameter WHERE key = 'mail.catchall.domain';
            INSERT INTO ir_config_parameter (key, value) VALUES ('mail.catchall.domain', 'localhost');
        "

        # Execute the SQL commands
        # Using || true to prevent script exit if a minor sql error occurs, but verifying execution via check
        if sudo -u postgres psql -d "$STG_DB_NAME" -c "$SANITIZE_SQL" > /dev/null 2>&1; then
            log_success "Database sanitized successfully."
        else
            log_warn "Warning: Failed to sanitize database completely (SQL command failed)."
        fi
    fi

    # 2. Fix Ownership
    log_info "Fixing DB Object Ownership to user: $STG_DB_USER"

    sudo -u postgres psql -d postgres -c "ALTER DATABASE \"$STG_DB_NAME\" OWNER TO \"$STG_DB_USER\"" > /dev/null

    # Run the PL/pgSQL block to fix tables, sequences, and views
    sudo -u postgres psql -d "$STG_DB_NAME" -c "
        DO \$\$
        DECLARE
            rec RECORD;
        BEGIN
            -- Tables
            FOR rec IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
                EXECUTE 'ALTER TABLE ' || quote_ident(rec.tablename) || ' OWNER TO \"${STG_DB_USER}\"';
            END LOOP;
            -- Sequences
            FOR rec IN (SELECT sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public') LOOP
                EXECUTE 'ALTER SEQUENCE ' || quote_ident(rec.sequence_name) || ' OWNER TO \"${STG_DB_USER}\"';
            END LOOP;
            -- Views
            FOR rec IN (SELECT table_name FROM information_schema.views WHERE table_schema = 'public') LOOP
                EXECUTE 'ALTER VIEW ' || quote_ident(rec.table_name) || ' OWNER TO \"${STG_DB_USER}\"';
            END LOOP;
        END \$\$;
    " > /dev/null 2>&1 || log_warn "Ownership fix script had minor issues, but proceeding."

else
    log_stage "[2/4] Skipping Database Clone (IS_RENEW_DB is false)."
fi


# 3. RESTART CONTAINER
# ---------------------------------------------------------
log_stage "[3/4] Restarting Staging Container..."

# Change directory to the dynamic STG_PATH_TO_ODOO
if cd "$STG_PATH_TO_ODOO"; then
    if [ "$JSON_MODE" = "true" ]; then
        if docker compose restart odoo >&2; then
            log_success "Container restarted."
        else
            log_error "Failed to restart docker container."
            exit 1
        fi
    else
        if docker compose restart odoo; then
            log_success "Container restarted."
        else
            log_error "Failed to restart docker container."
            exit 1
        fi
    fi
else
    log_error "Could not find directory $STG_PATH_TO_ODOO"
    exit 1
fi


# 4. UPDATE MODULES
# ---------------------------------------------------------
if [ -z "$MODULES_TO_UPDATE" ]; then
    log_stage "[4/4] Update module skipped..."
    log_warn "No specific modules listed."
    log_info "Tip: You can pass modules as the fourth argument: $0 $RELEASE_BRANCH $IS_RENEW_DB 'sale,inventory'"
else
    log_stage "[4/4] Updating Odoo Modules..."
    log_info "Waiting 10 seconds for Odoo to initialize..."
    sleep 10
    log_info "Updating modules: $MODULES_TO_UPDATE"
    # Using the 'odoo-module-upgrade' utility embedded in your image
    if [ "$JSON_MODE" = "true" ]; then
        if docker compose exec odoo odoo-module-upgrade "$STG_DB_NAME" --update="$MODULES_TO_UPDATE" >&2; then
            log_success "Modules updated successfully."
        else
            log_error "Failed to update modules."
            exit 1
        fi
    else
        if docker compose exec odoo odoo-module-upgrade "$STG_DB_NAME" --update="$MODULES_TO_UPDATE"; then
            log_success "Modules updated successfully."
        else
            log_error "Failed to update modules."
            exit 1
        fi
    fi
fi

if [ "$JSON_MODE" = "false" ]; then
    echo ""
    echo "=================================================="
    log_success "Deployment Complete!"
    echo "   Service:     $SERVICE_NAME"
    if [ "$IS_RENEW_DB" == "true" ]; then
        echo "   Database:    $STG_DB_NAME (Cloned from $PRD_DB_NAME)"
    fi
    echo "   Branch:      $RELEASE_BRANCH"
    echo "=================================================="
fi

# --- JSON Output Generation ---
if [ "$JSON_MODE" = "true" ]; then
    echo "{"
    echo '  "repositories": ['

    GIT_ROOT="$STG_PATH_TO_ODOO/git"
    FIRST_REPO=1

    if [ -d "$GIT_ROOT" ]; then
        for repo_dir in "$GIT_ROOT"/*/; do
            [ -d "$repo_dir" ] || continue
            repo_name=$(basename "$repo_dir")

            # Default values
            status="clean"
            # Note: We don't do full 'git status' check here to keep it fast,
            # but we can assume existing is 'clean' or 'not_git' unless we want to run git status.
            # The user asked for "list of current commit".

            if [ -d "$repo_dir/.git" ]; then
               commit_hash=$(sudo -u "$CURRENT_DIR_USER" git -C "$repo_dir" rev-parse --short HEAD 2>/dev/null || echo "unknown")
               commit_subject=$(sudo -u "$CURRENT_DIR_USER" git -C "$repo_dir" log -1 --format="%s" 2>/dev/null | tr -d '"\\' || echo "")
            else
               status="not_git"
               commit_hash=""
               commit_subject=""
            fi

            if [ $FIRST_REPO -eq 0 ]; then echo ","; fi
            FIRST_REPO=0

            echo "    {"
            echo "      \"name\": \"$repo_name\","
            echo "      \"status\": \"$status\","
            echo "      \"commit\": \"$commit_hash\","
            echo "      \"subject\": \"$commit_subject\","
            echo "      \"files\": []"
            echo -n "    }"
        done
    fi
    if [ -n "$MODULES_TO_UPDATE" ]; then
        echo "  ],"
        echo "  \"database_name\": \"$STG_DB_NAME\","
        echo '  "modules_to_upgrade": ['
        IFS=',' read -ra MODULES <<< "$MODULES_TO_UPDATE"
        FIRST_MODULE=1
        for module in "${MODULES[@]}"; do
            if [ $FIRST_MODULE -eq 0 ]; then echo ","; fi
            # Trim whitespace just in case
            module=$(echo "$module" | xargs)
            echo -n "    \"$module\""
            FIRST_MODULE=0
        done
        echo ""
        echo "  ]"
        echo "}"
    else
        echo "  ],"
        echo "  \"database_name\": \"$STG_DB_NAME\""
        echo "}"
    fi
fi
