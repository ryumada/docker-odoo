#!/usr/bin/env bash
set -e
# Category: Utility
# Description: Deploys release candidates (manual database operations).
# Usage: ./scripts/deploy_release_candidate_manual.sh <REPO_NAME> <BRANCH> <RENEW_DB> [MODULES]
# Dependencies: git, docker, pg_dump, psql, rsync, sudo

# Detect Repository Owner to run non-root commands as that user
CURRENT_DIR=$(dirname "$(readlink -f "$0")")
CURRENT_DIR_USER=$(stat -c '%U' "$CURRENT_DIR")
PATH_TO_ODOO=$(sudo -u "$CURRENT_DIR_USER" git -C "$(dirname "$(readlink -f "$0")")" rev-parse --show-toplevel)
SERVICE_NAME=$(basename "$PATH_TO_ODOO")
REPOSITORY_OWNER=$(stat -c '%U' "$PATH_TO_ODOO")

# Configuration
ENV_FILE=".env"
UPDATE_SCRIPT="./scripts/update-env-file.sh"
MAX_BACKUPS=3

# --- Logging Functions & Colors ---
# Define colors for log messages
readonly COLOR_RESET="\033[0m"
readonly COLOR_INFO="\033[0;34m"
readonly COLOR_SUCCESS="\033[0;32m"
readonly COLOR_WARN="\033[1;33m"
readonly COLOR_ERROR="\033[0;31m"
readonly COLOR_CYAN="\033[0;36m"

# Function to log messages with a specific color and emoji
log() {
    local color="$1"
    local emoji="$2"
    local message="$3"
    if [ "$JSON_MODE" = "true" ]; then
        echo -e "${color}[$(date +"%Y-%m-%d %H:%M:%S")] ${emoji} ${message}${COLOR_RESET}" >&2
    else
        echo -e "${color}[$(date +"%Y-%m-%d %H:%M:%S")] ${emoji} ${message}${COLOR_RESET}"
    fi
}

log_info() { log "${COLOR_INFO}" "â„¹ï¸" "$1"; }
log_success() { log "${COLOR_SUCCESS}" "âœ…" "$1"; }
log_warn() { log "${COLOR_WARN}" "âš ï¸" "$1"; }
log_error() {
    if [ "$JSON_MODE" = "true" ]; then
        echo "{\"error\": \"$1\"}"
    fi
    log "${COLOR_ERROR}" "âŒ" "$1"
}
log_stage() { log "${COLOR_CYAN}" "ðŸ“‹" "$1"; }

error_handler() {
  local exit_code=$1
  local line_no=$2
  local command_name=$3
  log_error "An error occurred on line $line_no."
  log_error "Exit Code: $exit_code"
  log_error "Command: $command_name"
  log_error "Note: The specific error message should be printed in the lines above this error."
  exit "$exit_code"
}

trap 'error_handler $? $LINENO "$BASH_COMMAND"' ERR

# --- Centralized Cleanup Hook ---
cleanup_temp_files() {
    local sql_file="/tmp/$STG_DB_NAME.sql"
    if [ -n "$STG_DB_NAME" ] && [ -f "$sql_file" ]; then
        rm -f "$sql_file"
    fi
}
trap cleanup_temp_files EXIT
# ------------------------------------

function get_next_prefix() {
    local env_file="$1"
    local current_count
    local next_count

    # Read existing count
    current_count=$(grep "^DB_PREFIX_COUNT=" "$env_file" | cut -d "=" -f 2 | tr -d '[:space:]')

    # Initialize if empty or not a number
    if [[ ! "$current_count" =~ ^[0-9]+$ ]]; then
        current_count=-1
    fi

    # Increment
    next_count=$((current_count + 1))

    # Reset if > 999
    if [ "$next_count" -gt 999 ]; then
        next_count=0
    fi

    # Update .env file
    if grep -q "^DB_PREFIX_COUNT=" "$env_file"; then
        sed -i "s/^DB_PREFIX_COUNT=.*/DB_PREFIX_COUNT=$next_count/" "$env_file"
    else
        echo "DB_PREFIX_COUNT=$next_count" >> "$env_file"
    fi

    # Output formatted with leading zeros
    printf "%03d" "$next_count"
}

function fail_with_json() {
    local message="$1"
    log_error "$message"
    exit 1
}

function list_databases() {
    local db_user_file="$PATH_TO_ODOO/.secrets/db_user"
    if [ ! -f "$db_user_file" ]; then
        log_error "Secrets file not found: $db_user_file"
        exit 1
    fi

    local db_user
    db_user=$(cat "$db_user_file" | tr -d '[:space:]')

    if [ -z "$db_user" ]; then
        log_error "Database user is empty in $db_user_file"
        exit 1
    fi

    log_info "Listing databases owned by user: $db_user"
    echo "--------------------------------------------------"
    sudo -u postgres psql -t -c "SELECT datname FROM pg_database WHERE datdba = (SELECT oid FROM pg_roles WHERE rolname = '$db_user');" | awk '{$1=$1};1' | grep -v '^\s*$' || echo "No databases found."
    echo "--------------------------------------------------"
    exit 0
}

function sanitize_database() {
    local db_name="$1"
    log_info "Sanitizing the database (Disabling Emails & Crons)"

    # SQL commands to disable outgoing email, crons, and mail servers
    local SANITIZE_SQL="
      -- Disable all Outgoing Mail Servers
      UPDATE ir_mail_server SET active = false;

      -- Disable ALL crons initially (Safety first)
      UPDATE ir_cron SET active = false;

      -- Set System Parameter to prevent catching emails
      DELETE FROM ir_config_parameter WHERE key = 'mail.catchall.domain';
      INSERT INTO ir_config_parameter (key, value) VALUES ('mail.catchall.domain', 'localhost');
    "

    # Execute the SQL commands
    if sudo -u postgres psql -d "$db_name" -c "$SANITIZE_SQL" > /dev/null 2>&1; then
        log_success "Database sanitized successfully."
    else
        log_warn "Warning: Failed to sanitize database completely (SQL command failed)."
    fi
}

function change_db_ownership() {
    local db_name="$1"
    local db_user="$2"

    log_info "Changing ownership of DB $db_name to $db_user"

    sudo -u postgres psql -d postgres -c "ALTER DATABASE \"$db_name\" OWNER TO \"$db_user\"" > /dev/null 2>&1 || { log_error "Error changing DB owner"; exit 1; }

    sudo -u postgres psql -d "$db_name" -c "
      -- Change the owner of all tables
      DO \$\$
      DECLARE
        rec RECORD;
      BEGIN
        FOR rec IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
          EXECUTE 'ALTER TABLE ' || quote_ident(rec.tablename) || ' OWNER TO \"${db_user}\"';
        END LOOP;
      END \$\$;

      -- Change the owner of all sequences
      DO \$\$
      DECLARE
          rec RECORD;
      BEGIN
        FOR rec IN (SELECT sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public') LOOP
          EXECUTE 'ALTER SEQUENCE ' || quote_ident(rec.sequence_name) || ' OWNER TO \"${db_user}\"';
        END LOOP;
      END \$\$;

      -- Change the owner of all views
      DO \$\$
      DECLARE
        rec RECORD;
      BEGIN
        FOR rec IN (SELECT table_name FROM information_schema.views WHERE table_schema = 'public') LOOP
          EXECUTE 'ALTER VIEW ' || quote_ident(rec.table_name) || ' OWNER TO \"${db_user}\"';
        END LOOP;
      END \$\$;
    " > /dev/null 2>&1 || { log_error "Error changing ownership of tables/sequences/views"; exit 1; }
}

# ------------------------------------

# Self-elevate to root if not already
if [ "$(id -u)" -ne 0 ]; then
    log_info "Elevating permissions to root..."
    # shellcheck disable=SC2093
    exec sudo "$0" "$@" # Re-run the script with sudo
    log_error "Failed to elevate to root. Please run with sudo." # This will only run if exec fails
    exit 1
fi

# --- JSON Mode Detection ---
JSON_MODE="false"
ARGS=()
for arg in "$@"; do
    if [[ "$arg" == "json" ]]; then
        JSON_MODE="true"
    else
        ARGS+=("$arg")
    fi
done
set -- "${ARGS[@]}"

# --- Usage / Help Function ---
display_usage() {
    echo -e "${COLOR_INFO}Usage:${COLOR_RESET} sudo $0 <REPO_NAME> <BRANCH> <RENEW_DB> [DB_NAME] [MODULES]"
    echo -e "       sudo $0 --list-db"
    echo ""
    echo -e "${COLOR_CYAN}Arguments:${COLOR_RESET}"
    echo -e "  ${COLOR_SUCCESS}1. REPO_NAME${COLOR_RESET}       : The directory name of the git repository (inside stg/git/)."
    echo -e "  ${COLOR_SUCCESS}2. BRANCH${COLOR_RESET}          : The target Git branch to checkout (e.g., 'staging', 'main')."
    echo -e "  ${COLOR_SUCCESS}3. RENEW_DB${COLOR_RESET}        : Set to 'true' or '1' to drop Staging DB and clone from Production."
    echo -e "                       Set to 'false' or '0' to keep existing Staging data."
    echo -e "  ${COLOR_SUCCESS}4. DB_NAME${COLOR_RESET}         : (Required if RENEW_DB is false) The name of the target database."
    echo -e "  ${COLOR_SUCCESS}5. MODULES${COLOR_RESET}         : (Optional) Comma-separated list of modules to update (e.g., 'sale,stock')."
    echo ""
    echo -e "${COLOR_CYAN}Options:${COLOR_RESET}"
    echo -e "  ${COLOR_SUCCESS}-h, --help${COLOR_RESET}         : Show this help message and exit."
    echo -e "  ${COLOR_SUCCESS}-l, --list-db${COLOR_RESET}      : List all databases owned by the project's pg user and exit."
    echo ""
}

# --- Check for Help or List Flags ---
if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    display_usage
    exit 0
elif [[ "$1" == "-l" || "$1" == "--list-db" ]]; then
    list_databases
fi

# --- Inputs ---
GIT_REPO_NAME=$1
RELEASE_BRANCH=$2
IS_RENEW_DB=$3

case "${IS_RENEW_DB}" in
    1|true|True|TRUE) IS_RENEW_DB=true ;;
    *) IS_RENEW_DB=false ;;
esac

TARGET_DB=""
MODULES_TO_UPDATE=""

if [ "$IS_RENEW_DB" = "true" ]; then
    MODULES_TO_UPDATE=$4
else
    TARGET_DB=$4
    MODULES_TO_UPDATE=$5
fi

# --- Validation ---
MISSING_ARGS=false
if [ -z "$GIT_REPO_NAME" ]; then
    log_error "Missing Argument 1: Git Repo Name"
    MISSING_ARGS=true
fi
if [ -z "$RELEASE_BRANCH" ]; then
    log_error "Missing Argument 2: Release Branch"
    MISSING_ARGS=true
fi
if [ -z "$IS_RENEW_DB" ]; then
    log_error "Missing Argument 3: Clone DB Flag (true/false)"
    MISSING_ARGS=true
fi
if [ "$IS_RENEW_DB" = "false" ] && [ -z "$TARGET_DB" ] && [ -n "$MODULES_TO_UPDATE" ]; then
    log_error "Missing Argument 4: Target Database Name (Required when RENEW_DB is false and modules are provided)"
    MISSING_ARGS=true
fi
if [ "$MISSING_ARGS" == "true" ]; then
    echo ""
    display_usage
    exit 1
fi

STG_PATH_TO_ODOO=$PATH_TO_ODOO
SERVICE_NAME_PRD=${SERVICE_NAME%-*} # Assumes format like 'project-stg' -> 'project' OR 'project-16-stg' -> 'project-16'

STG_ENV_FILE="$STG_PATH_TO_ODOO/.env"

if [ "$IS_RENEW_DB" = "true" ]; then
    STG_DB_NAME_FROM_ENV=$(grep "^DB_NAME=" "$STG_ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')
    STG_DB_NAME="$STG_DB_NAME_FROM_ENV"

    if [ -z "$STG_DB_NAME" ]; then
        # Fallback if .env is empty
        STG_DB_NAME="$(get_next_prefix "$STG_ENV_FILE")-$SERVICE_NAME-$(date +"%Y%m%d-%H%M%S")"
    fi
else
    STG_DB_NAME="$TARGET_DB"
fi

STG_GIT_PATH="$STG_PATH_TO_ODOO/git/$GIT_REPO_NAME"
if [ ! -d "$STG_GIT_PATH" ]; then
    fail_with_json "Git path not found at: $STG_GIT_PATH"
fi

# Check if remote branch exists
log_info "Checking if remote branch '$RELEASE_BRANCH' exists..."
if [ "$JSON_MODE" = "true" ]; then
    GIT_LS_REMOTE_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH ls-remote --exit-code --heads origin $RELEASE_BRANCH > /dev/null 2>&1"
else
    GIT_LS_REMOTE_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH ls-remote --exit-code --heads origin $RELEASE_BRANCH > /dev/null"
fi

if ! eval "$GIT_LS_REMOTE_CMD"; then
    fail_with_json "Remote branch '$RELEASE_BRANCH' not found in repository '$GIT_REPO_NAME'."
fi

log_info "ðŸš€ Starting Deployment for Service: $SERVICE_NAME"
# ... (logging specific to this script)

# 1. SWITCH BRANCH
# ---------------------------------------------------------
log_stage "[1/4] Switching Git Branch..."
if [ "$JSON_MODE" = "true" ]; then
    GIT_FETCH_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH fetch >&2"
else
    GIT_FETCH_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH fetch"
fi
if eval "$GIT_FETCH_CMD"; then log_info "Fetch success."; else log_error "Failed to fetch."; exit 1; fi

if [ "$JSON_MODE" = "true" ]; then
    GIT_RESET_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH reset --hard >&2"
else
    GIT_RESET_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH reset --hard"
fi
if eval "$GIT_RESET_CMD"; then log_info "Local changes discarded."; else log_warn "Could not reset git changes."; fi

if [ "$JSON_MODE" = "true" ]; then
    GIT_CHECKOUT_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH checkout $RELEASE_BRANCH >&2"
else
    GIT_CHECKOUT_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH checkout $RELEASE_BRANCH"
fi
if eval "$GIT_CHECKOUT_CMD"; then log_success "Checked out branch: $RELEASE_BRANCH"; else log_error "Failed to checkout."; exit 1; fi

if [ "$JSON_MODE" = "true" ]; then
    GIT_PULL_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH pull >&2"
else
    GIT_PULL_CMD="sudo -u $CURRENT_DIR_USER git -C $STG_GIT_PATH pull"
fi
if eval "$GIT_PULL_CMD"; then log_success "Code is up to date."; else log_error "Failed to pull code."; exit 1; fi


# 2. CLONE DATABASE (Manual)
# ---------------------------------------------------------
if [ "$IS_RENEW_DB" == "true" ]; then
    PRD_PATH_TO_ODOO="$STG_PATH_TO_ODOO/../$SERVICE_NAME_PRD"
    PRD_ENV_FILE="$PRD_PATH_TO_ODOO/.env"
    if [ ! -f "$PRD_ENV_FILE" ]; then log_error "Prod .env not found."; exit 1; fi

    PRD_DB_NAME=$(grep "^DB_NAME=" "$PRD_ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g')
    if [ -z "$PRD_DB_NAME" ]; then log_error "DB_NAME not set in prod."; exit 1; fi

    log_stage "[2/4] Cloning Production Database to Staging (Manual Mode)..."

    ODOO_FILESTORE_PATH_PRD="/var/lib/odoo/$SERVICE_NAME_PRD/filestore/$PRD_DB_NAME"
    ODOO_FILESTORE_PATH_ENV="/var/lib/odoo/$SERVICE_NAME/filestore/$STG_DB_NAME"
    ODOO_DB_USER_ENV=$(cat "$STG_PATH_TO_ODOO/.secrets/db_user")

    log_info "Dump $PRD_DB_NAME to temporary file"
    sudo -u postgres pg_dump -d "$PRD_DB_NAME" -f "/tmp/$STG_DB_NAME.sql" > /dev/null 2>&1 || { log_error "Error dumping database"; exit 1; }

    # Sync Filestore
    if [ -d "$ODOO_FILESTORE_PATH_ENV" ]; then
        log_warn "Remove old filestore $STG_DB_NAME"
        rm -rf "$ODOO_FILESTORE_PATH_ENV"
    fi
    mkdir -p "$ODOO_FILESTORE_PATH_ENV"
    rsync -a "$ODOO_FILESTORE_PATH_PRD/" "$ODOO_FILESTORE_PATH_ENV" > /dev/null 2>&1 || { log_error "Error copying filestore"; exit 1; }
    chown -R odoo: "$ODOO_FILESTORE_PATH_ENV"

    # Stop Staging
    docker compose -f "$STG_PATH_TO_ODOO/docker-compose.yml" stop > /dev/null 2>&1 || { log_error "Error stopping staging"; exit 1; }

    log_warn "Drop old database $STG_DB_NAME"
    sudo -u postgres psql -d postgres -c "DROP DATABASE IF EXISTS \"$STG_DB_NAME\" WITH (FORCE)" > /dev/null 2>&1 || { log_warn "Error dropping DB, proceeding..."; }

    log_info "Create new database $STG_DB_NAME"
    sudo -u postgres psql -d postgres -c "CREATE DATABASE \"$STG_DB_NAME\"" > /dev/null 2>&1 || { log_error "Error creating DB"; exit 1; }

    log_info "Restore $STG_DB_NAME from dump"
    sudo -u postgres psql -d "$STG_DB_NAME" -f "/tmp/$STG_DB_NAME.sql" > /dev/null 2>&1 || { log_error "Error restoring DB"; exit 1; }

    # Neutralize
    NEUTRALIZE_DB=$(grep "^NEUTRALIZE_DATABASE=" "$PRD_ENV_FILE" | cut -d "=" -f 2 | sed 's/^[[:space:]\n]*//g' | sed 's/[[:space:]\n]*$//g' | tr '[:upper:]' '[:lower:]')
    if [ -z "$NEUTRALIZE_DB" ]; then NEUTRALIZE_DB="true"; fi

    if [ "$NEUTRALIZE_DB" = "true" ]; then
        sanitize_database "$STG_DB_NAME"
    fi

    change_db_ownership "$STG_DB_NAME" "$ODOO_DB_USER_ENV"

    log_success "Database clone complete."
else
    log_stage "[2/4] Skipping Database Clone."
fi

# 3. RESTART CONTAINER
# ---------------------------------------------------------
log_stage "[3/4] Restarting Staging Container..."
cd "$STG_PATH_TO_ODOO"
if [ "$JSON_MODE" = "true" ]; then
    if docker compose restart odoo >&2; then log_success "Restarted."; else log_error "Restart failed."; exit 1; fi
else
    if docker compose restart odoo; then log_success "Restarted."; else log_error "Restart failed."; exit 1; fi
fi

# 4. UPDATE MODULES
# ---------------------------------------------------------
if [ -z "$MODULES_TO_UPDATE" ]; then
    log_stage "[4/4] Update module skipped..."
else
    log_stage "[4/4] Updating Odoo Modules..."
    sleep 10
    MODULE_UPDATE_ERROR=false
    UPDATE_OUTPUT=""
    TEMP_UPDATE_LOG=$(mktemp)
    if [ "$JSON_MODE" = "true" ]; then
        docker compose exec odoo odoo-module-upgrade "$STG_DB_NAME" --update="$MODULES_TO_UPDATE" 2>&1 | tee "$TEMP_UPDATE_LOG" >&2
        if [ ${PIPESTATUS[0]} -ne 0 ]; then MODULE_UPDATE_ERROR=true; fi
        UPDATE_OUTPUT=$(cat "$TEMP_UPDATE_LOG")
        if [ "$MODULE_UPDATE_ERROR" = "false" ]; then
            log_success "Modules updated."
        else
            log_warn "Process complete, but the module update encountered an error."
            log "${COLOR_ERROR}" "âŒ" "Odoo module upgrade log (Summary):"
            echo "$UPDATE_OUTPUT" >&2
        fi
    else
        docker compose exec odoo odoo-module-upgrade "$STG_DB_NAME" --update="$MODULES_TO_UPDATE" 2>&1 | tee "$TEMP_UPDATE_LOG"
        if [ ${PIPESTATUS[0]} -ne 0 ]; then MODULE_UPDATE_ERROR=true; fi
        UPDATE_OUTPUT=$(cat "$TEMP_UPDATE_LOG")
        if [ "$MODULE_UPDATE_ERROR" = "false" ]; then
            log_success "Modules updated."
        else
            log_warn "Process complete, but the module update encountered an error."
            log "${COLOR_ERROR}" "âŒ" "Odoo module upgrade log (Summary):"
            echo "$UPDATE_OUTPUT"
        fi
    fi
    rm -f "$TEMP_UPDATE_LOG"
fi

if [ "$JSON_MODE" = "false" ]; then
    echo ""
    log_success "Deployment Complete!"
fi

# --- JSON Output Generation ---
if [ "$JSON_MODE" = "true" ]; then
    echo "{"
    echo '  "repositories": ['
    GIT_ROOT="$STG_PATH_TO_ODOO/git"
    FIRST_REPO=1
    if [ -d "$GIT_ROOT" ]; then
        for repo_dir in "$GIT_ROOT"/*/; do
            [ -d "$repo_dir" ] || continue
            repo_name=$(basename "$repo_dir")
            status="clean" # Simplified
            if [ -d "$repo_dir/.git" ]; then
               commit_hash=$(sudo -u "$CURRENT_DIR_USER" git -C "$repo_dir" rev-parse --short HEAD 2>/dev/null || echo "unknown")
               commit_subject=$(sudo -u "$CURRENT_DIR_USER" git -C "$repo_dir" log -1 --format="%s" 2>/dev/null | tr -d '"\\' || echo "")
            else
               status="not_git"; commit_hash=""; commit_subject=""
            fi
            if [ $FIRST_REPO -eq 0 ]; then echo ","; fi
            FIRST_REPO=0
            echo "    { \"name\": \"$repo_name\", \"status\": \"$status\", \"commit\": \"$commit_hash\", \"subject\": \"$commit_subject\", \"files\": [] }"
        done
    fi
    echo ""
    echo "  ],"
    echo "  \"database_name\": \"$STG_DB_NAME\""
    if [ -n "$MODULES_TO_UPDATE" ]; then
        echo ", \"modules_to_upgrade\": [ \"$MODULES_TO_UPDATE\" ]"
    fi
    if [ "$MODULE_UPDATE_ERROR" = "true" ]; then
        echo ", \"error\": true"
        if command -v python3 >/dev/null 2>&1; then
            JSON_SAFE_LOG=$(python3 -c 'import json, sys; print(json.dumps(sys.stdin.read()))' <<< "$UPDATE_OUTPUT")
        else
            ESCAPED=$(echo "$UPDATE_OUTPUT" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | awk '{printf "%s\\n", $0}' | sed 's/\\n$//')
            JSON_SAFE_LOG="\"$ESCAPED\""
        fi
        echo ", \"module_upgrade_log\": $JSON_SAFE_LOG"
    fi
    echo "}"
fi
